<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Machine Learning - Breast Cancer Wisconsin</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.18.0/plotly.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        h2 {
            color: #34495e;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-top: 40px;
        }
        .section {
            margin: 30px 0;
            padding: 20px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        .controls {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
            align-items: center;
        }
        button {
            padding: 12px 24px;
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }
        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        input, select {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }
        input:focus, select:focus {
            border-color: #3498db;
            outline: none;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .metric-card {
            background: linear-gradient(45deg, #f8f9fa, #e9ecef);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            border-left: 5px solid #3498db;
            transition: transform 0.3s ease;
        }
        .metric-card:hover {
            transform: translateY(-5px);
        }
        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #2c3e50;
        }
        .metric-label {
            color: #7f8c8d;
            font-size: 0.9em;
            margin-top: 5px;
        }
        .plot-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        .info-box {
            background: linear-gradient(45deg, #e8f5e8, #f0f8f0);
            border-left: 5px solid #27ae60;
            padding: 15px;
            margin: 15px 0;
            border-radius: 10px;
        }
        .warning-box {
            background: linear-gradient(45deg, #fff3cd, #ffeaa7);
            border-left: 5px solid #f39c12;
            padding: 15px;
            margin: 15px 0;
            border-radius: 10px;
        }
        .progress-bar {
            width: 100%;
            height: 10px;
            background: #ecf0f1;
            border-radius: 5px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2980b9);
            width: 0%;
            transition: width 0.3s ease;
        }
        .data-table {
            overflow-x: auto;
            margin: 20px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            font-weight: bold;
        }
        tr:hover {
            background: #f8f9fa;
        }
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
<div class="container">
    <h1>üß¨ Machine Learning - Breast Cancer Wisconsin Dataset</h1>

    <div class="section">
        <h2>üìä 1. Carregamento e Pr√©-processamento dos Dados</h2>
        <div class="controls">
            <button onclick="loadData()">Carregar Dataset</button>
            <button onclick="preprocessData()" id="preprocessBtn" disabled>Pr√©-processar Dados</button>
            <button onclick="showDataInfo()" id="infoBtn" disabled>Mostrar Informa√ß√µes</button>
        </div>
        <div id="dataInfo"></div>
        <div id="dataPreview"></div>
    </div>

    <div class="section">
        <h2>üéØ 2. Classifica√ß√£o com K-Nearest Neighbors (KNN)</h2>
        <div class="controls">
            <label>Valor de K:</label>
            <input type="number" id="kValue" value="5" min="1" max="50">
            <button onclick="trainKNN()" id="knnBtn" disabled>Treinar KNN</button>
            <button onclick="analyzeKPerformance()" id="kAnalysisBtn" disabled>An√°lise de Performance K</button>
        </div>
        <div id="knnResults"></div>
        <div id="knnMetrics" class="metrics"></div>
        <div id="kPerformancePlot" class="plot-container"></div>
    </div>

    <div class="section">
        <h2>üîß 3. Dados Sint√©ticos com Ru√≠do</h2>
        <div class="controls">
            <label>N√≠vel de Ru√≠do:</label>
            <input type="range" id="noiseLevel" min="0" max="0.5" step="0.05" value="0.1">
            <span id="noiseLevelValue">0.1</span>
            <label>Quantidade de Amostras:</label>
            <input type="number" id="syntheticSamples" value="100" min="10" max="1000">
            <button onclick="generateSyntheticData()" id="syntheticBtn" disabled>Gerar Dados Sint√©ticos</button>
            <button onclick="trainWithSynthetic()" id="syntheticTrainBtn" disabled>Treinar com Dados Sint√©ticos</button>
        </div>
        <div id="syntheticResults"></div>
        <div id="syntheticMetrics" class="metrics"></div>
    </div>

    <div class="section">
        <h2>üìà 4. Regress√£o Linear - Predi√ß√£o da √Årea M√©dia</h2>
        <div class="controls">
            <button onclick="trainLinearRegression()" id="regressionBtn" disabled>Treinar Regress√£o Linear</button>
            <button onclick="analyzeResiduals()" id="residualsBtn" disabled>An√°lise de Res√≠duos</button>
        </div>
        <div id="regressionResults"></div>
        <div id="regressionMetrics" class="metrics"></div>
        <div id="regressionPlots" class="plot-container"></div>
        <div id="residualsPlot" class="plot-container"></div>
    </div>

    <div class="section">
        <h2>üìã 5. Compara√ß√£o e An√°lise Final</h2>
        <div id="finalAnalysis"></div>
        <div id="performanceComparison" class="plot-container"></div>
    </div>
</div>

<script>
    // Vari√°veis globais para armazenar dados e modelos
    let rawData = [];
    let processedData = [];
    let features = [];
    let target = [];
    let featureNames = ['mean_radius', 'mean_texture', 'mean_perimeter', 'mean_area', 'mean_smoothness'];
    let knnModel = null;
    let syntheticData = [];
    let regressionModel = null;
    let results = {};

    // Simular dataset Breast Cancer Wisconsin
    function generateBreastCancerData() {
        const data = [];
        const n = 569; // Tamanho real do dataset

        for (let i = 0; i < n; i++) {
            const isMalignant = Math.random() > 0.63; // ~37% malignos

            // Gerar caracter√≠sticas baseadas na classe
            const baseRadius = isMalignant ?
                14 + Math.random() * 8 : // Malignos: maior raio
                12 + Math.random() * 4;  // Benignos: menor raio

            const baseTexture = isMalignant ?
                19 + Math.random() * 10 :
                17 + Math.random() * 6;

            const basePerimeter = baseRadius * 2 * Math.PI + (Math.random() - 0.5) * 20;
            const baseArea = Math.PI * baseRadius * baseRadius + (Math.random() - 0.5) * 200;
            const baseSmoothness = isMalignant ?
                0.1 + Math.random() * 0.05 :
                0.08 + Math.random() * 0.04;

            data.push({
                mean_radius: baseRadius,
                mean_texture: baseTexture,
                mean_perimeter: basePerimeter,
                mean_area: baseArea,
                mean_smoothness: baseSmoothness,
                diagnosis: isMalignant ? 1 : 0 // 1 = Maligno, 0 = Benigno
            });
        }

        return data;
    }

    function loadData() {
        document.getElementById('dataInfo').innerHTML = '<div class="loading"></div> Carregando dataset...';

        setTimeout(() => {
            rawData = generateBreastCancerData();
            document.getElementById('dataInfo').innerHTML = `
                    <div class="info-box">
                        <strong>Dataset carregado com sucesso!</strong><br>
                        Total de amostras: ${rawData.length}<br>
                        Caracter√≠sticas: ${featureNames.join(', ')}<br>
                        Classes: Benigno (0), Maligno (1)
                    </div>
                `;

            // Mostrar preview dos dados
            showDataPreview();

            document.getElementById('preprocessBtn').disabled = false;
            document.getElementById('infoBtn').disabled = false;
        }, 1000);
    }

    function showDataPreview() {
        const preview = rawData.slice(0, 10);
        let tableHTML = `
                <div class="data-table">
                    <h3>Preview dos Dados (10 primeiras amostras)</h3>
                    <table>
                        <thead>
                            <tr>
                                <th>√çndice</th>
                                ${featureNames.map(name => `<th>${name}</th>`).join('')}
                                <th>Diagn√≥stico</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

        preview.forEach((row, idx) => {
            tableHTML += `
                    <tr>
                        <td>${idx + 1}</td>
                        ${featureNames.map(name => `<td>${row[name].toFixed(3)}</td>`).join('')}
                        <td>${row.diagnosis === 1 ? 'Maligno' : 'Benigno'}</td>
                    </tr>
                `;
        });

        tableHTML += '</tbody></table></div>';
        document.getElementById('dataPreview').innerHTML = tableHTML;
    }

    function preprocessData() {
        document.getElementById('dataInfo').innerHTML += '<div class="loading"></div> Pr√©-processando dados...';

        setTimeout(() => {
            // Separar features e target
            features = rawData.map(row => featureNames.map(name => row[name]));
            target = rawData.map(row => row.diagnosis);

            // Normalizar features (z-score)
            const means = [];
            const stds = [];

            for (let i = 0; i < featureNames.length; i++) {
                const column = features.map(row => row[i]);
                const mean = column.reduce((a, b) => a + b) / column.length;
                const std = Math.sqrt(column.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / column.length);

                means.push(mean);
                stds.push(std);

                for (let j = 0; j < features.length; j++) {
                    features[j][i] = (features[j][i] - mean) / std;
                }
            }

            processedData = features.map((row, idx) => ({
                features: row,
                target: target[idx]
            }));

            document.getElementById('dataInfo').innerHTML += `
                    <div class="info-box">
                        <strong>Pr√©-processamento conclu√≠do!</strong><br>
                        ‚úÖ Features normalizadas (z-score)<br>
                        ‚úÖ Dados separados em features e target<br>
                        ‚úÖ ${processedData.length} amostras processadas
                    </div>
                `;

            // Habilitar pr√≥ximos passos
            document.getElementById('knnBtn').disabled = false;
            document.getElementById('syntheticBtn').disabled = false;
            document.getElementById('regressionBtn').disabled = false;
        }, 1000);
    }

    function showDataInfo() {
        const malignant = target.filter(t => t === 1).length;
        const benign = target.filter(t => t === 0).length;

        const infoHTML = `
                <div class="info-box">
                    <h3>üìä Informa√ß√µes do Dataset</h3>
                    <strong>Distribui√ß√£o das Classes:</strong><br>
                    üî¥ Malignos: ${malignant} (${(malignant/target.length*100).toFixed(1)}%)<br>
                    üü¢ Benignos: ${benign} (${(benign/target.length*100).toFixed(1)}%)<br><br>

                    <strong>Estat√≠sticas das Features (dados originais):</strong><br>
                    ${featureNames.map((name, idx) => {
            const column = rawData.map(row => row[name]);
            const min = Math.min(...column);
            const max = Math.max(...column);
            const mean = column.reduce((a, b) => a + b) / column.length;
            return `${name}: Min=${min.toFixed(2)}, Max=${max.toFixed(2)}, M√©dia=${mean.toFixed(2)}`;
        }).join('<br>')}
                </div>
            `;

        document.getElementById('dataInfo').innerHTML += infoHTML;
    }

    // Fun√ß√£o para calcular dist√¢ncia euclidiana
    function euclideanDistance(point1, point2) {
        return Math.sqrt(
            point1.reduce((sum, val, idx) => sum + Math.pow(val - point2[idx], 2), 0)
        );
    }

    // Implementa√ß√£o do KNN
    function knnPredict(trainData, testPoint, k) {
        // Calcular dist√¢ncias
        const distances = trainData.map(point => ({
            distance: euclideanDistance(point.features, testPoint),
            target: point.target
        }));

        // Ordenar por dist√¢ncia e pegar os k vizinhos mais pr√≥ximos
        distances.sort((a, b) => a.distance - b.distance);
        const neighbors = distances.slice(0, k);

        // Vota√ß√£o majorit√°ria
        const votes = neighbors.reduce((acc, neighbor) => {
            acc[neighbor.target] = (acc[neighbor.target] || 0) + 1;
            return acc;
        }, {});

        return Object.keys(votes).reduce((a, b) => votes[a] > votes[b] ? a : b);
    }

    function trainKNN() {
        const k = parseInt(document.getElementById('kValue').value);
        document.getElementById('knnResults').innerHTML = '<div class="loading"></div> Treinando modelo KNN...';

        setTimeout(() => {
            // Dividir dados em treino e teste (80/20)
            const shuffled = [...processedData].sort(() => Math.random() - 0.5);
            const trainSize = Math.floor(shuffled.length * 0.8);
            const trainData = shuffled.slice(0, trainSize);
            const testData = shuffled.slice(trainSize);

            // Fazer predi√ß√µes
            const predictions = testData.map(point =>
                parseInt(knnPredict(trainData, point.features, k))
            );
            const actual = testData.map(point => point.target);

            // Calcular m√©tricas
            const accuracy = predictions.filter((pred, idx) => pred === actual[idx]).length / predictions.length;

            // Matriz de confus√£o
            let tp = 0, tn = 0, fp = 0, fn = 0;
            predictions.forEach((pred, idx) => {
                if (pred === 1 && actual[idx] === 1) tp++;
                else if (pred === 0 && actual[idx] === 0) tn++;
                else if (pred === 1 && actual[idx] === 0) fp++;
                else if (pred === 0 && actual[idx] === 1) fn++;
            });

            const precision = tp / (tp + fp) || 0;
            const recall = tp / (tp + fn) || 0;
            const f1Score = 2 * (precision * recall) / (precision + recall) || 0;

            // Armazenar resultados
            results.knn = {
                k: k,
                accuracy: accuracy,
                precision: precision,
                recall: recall,
                f1Score: f1Score,
                confusionMatrix: { tp, tn, fp, fn }
            };

            // Mostrar resultados
            document.getElementById('knnResults').innerHTML = `
                    <div class="info-box">
                        <strong>üéØ Modelo KNN Treinado (K=${k})</strong><br>
                        Dados de treino: ${trainData.length} amostras<br>
                        Dados de teste: ${testData.length} amostras<br>
                        ‚úÖ Treinamento conclu√≠do com sucesso!
                    </div>
                `;

            // Mostrar m√©tricas
            document.getElementById('knnMetrics').innerHTML = `
                    <div class="metric-card">
                        <div class="metric-value">${(accuracy * 100).toFixed(1)}%</div>
                        <div class="metric-label">Acur√°cia</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${(precision * 100).toFixed(1)}%</div>
                        <div class="metric-label">Precis√£o</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${(recall * 100).toFixed(1)}%</div>
                        <div class="metric-label">Recall</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${(f1Score * 100).toFixed(1)}%</div>
                        <div class="metric-label">F1-Score</div>
                    </div>
                `;

            document.getElementById('kAnalysisBtn').disabled = false;
        }, 1500);
    }

    function analyzeKPerformance() {
        document.getElementById('kPerformancePlot').innerHTML = '<div class="loading"></div> Analisando performance para diferentes valores de K...';

        setTimeout(() => {
            const kValues = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21];
            const accuracies = [];

            // Dividir dados uma vez
            const shuffled = [...processedData].sort(() => Math.random() - 0.5);
            const trainSize = Math.floor(shuffled.length * 0.8);
            const trainData = shuffled.slice(0, trainSize);
            const testData = shuffled.slice(trainSize);

            kValues.forEach(k => {
                const predictions = testData.map(point =>
                    parseInt(knnPredict(trainData, point.features, k))
                );
                const actual = testData.map(point => point.target);
                const accuracy = predictions.filter((pred, idx) => pred === actual[idx]).length / predictions.length;
                accuracies.push(accuracy);
            });

            // Plotar gr√°fico
            const trace = {
                x: kValues,
                y: accuracies.map(acc => acc * 100),
                type: 'scatter',
                mode: 'lines+markers',
                marker: { color: '#3498db', size: 8 },
                line: { color: '#3498db', width: 3 },
                name: 'Acur√°cia'
            };

            const layout = {
                title: 'Performance do KNN vs Valor de K',
                xaxis: { title: 'Valor de K' },
                yaxis: { title: 'Acur√°cia (%)' },
                showlegend: false,
                plot_bgcolor: 'rgba(0,0,0,0)',
                paper_bgcolor: 'rgba(0,0,0,0)'
            };

            Plotly.newPlot('kPerformancePlot', [trace], layout);

            // Encontrar melhor K
            const bestK = kValues[accuracies.indexOf(Math.max(...accuracies))];
            const bestAccuracy = Math.max(...accuracies);

            document.getElementById('kPerformancePlot').innerHTML += `
                    <div class="info-box">
                        <strong>üìä An√°lise de Performance K:</strong><br>
                        üèÜ Melhor K: ${bestK} (Acur√°cia: ${(bestAccuracy * 100).toFixed(1)}%)<br>
                        üìà Valores testados: ${kValues.join(', ')}<br>
                        üí° Recomenda√ß√£o: Use K=${bestK} para melhor performance
                    </div>
                `;
        }, 2000);
    }

    // Atualizar slider de ru√≠do
    document.getElementById('noiseLevel').addEventListener('input', function() {
        document.getElementById('noiseLevelValue').textContent = this.value;
    });

    function generateSyntheticData() {
        const noiseLevel = parseFloat(document.getElementById('noiseLevel').value);
        const numSamples = parseInt(document.getElementById('syntheticSamples').value);

        document.getElementById('syntheticResults').innerHTML = '<div class="loading"></div> Gerando dados sint√©ticos...';

        setTimeout(() => {
            syntheticData = [];

            for (let i = 0; i < numSamples; i++) {
                // Selecionar amostra aleat√≥ria original
                const originalIdx = Math.floor(Math.random() * processedData.length);
                const original = processedData[originalIdx];

                // Adicionar ru√≠do
                const noisyFeatures = original.features.map(feature =>
                    feature + (Math.random() - 0.5) * 2 * noiseLevel
                );

                syntheticData.push({
                    features: noisyFeatures,
                    target: original.target
                });
            }

            document.getElementById('syntheticResults').innerHTML = `
                    <div class="info-box">
                        <strong>üîß Dados Sint√©ticos Gerados!</strong><br>
                        Amostras sint√©ticas: ${syntheticData.length}<br>
                        N√≠vel de ru√≠do: ${noiseLevel}<br>
                        Baseado em amostras originais com ru√≠do gaussiano
                    </div>
                `;

            document.getElementById('syntheticTrainBtn').disabled = false;
        }, 1000);
    }

    function trainWithSynthetic() {
        const k = parseInt(document.getElementById('kValue').value);
        document.getElementById('syntheticResults').innerHTML += '<div class="loading"></div> Treinando com dados sint√©ticos...';

        setTimeout(() => {
            // Combinar dados originais com sint√©ticos
            const combinedData = [...processedData, ...syntheticData];

            // Dividir em treino e teste
            const shuffled = [...combinedData].sort(() => Math.random() - 0.5);
            const trainSize = Math.floor(shuffled.length * 0.8);
            const trainData = shuffled.slice(0, trainSize);
            const testData = shuffled.slice(trainSize);

            // Treinar e avaliar
            const predictions = testData.map(point =>
                parseInt(knnPredict(trainData, point.features, k))
            );
            const actual = testData.map(point => point.target);
            const accuracy = predictions.filter((pred, idx) => pred === actual[idx]).length / predictions.length;

            // Calcular m√©tricas
            let tp = 0, tn = 0, fp = 0, fn = 0;
            predictions.forEach((pred, idx) => {
                if (pred === 1 && actual[idx] === 1) tp++;
                else if (pred === 0 && actual[idx] === 0) tn++;
                else if (pred === 1 && actual[idx] === 0) fp++;
                else if (pred === 0 && actual[idx] === 1) fn++;
            });

            const precision = tp / (tp + fp) || 0;
            const recall = tp / (tp + fn) || 0;
            const f1Score = 2 * (precision * recall) / (precision + recall) || 0;

            results.knnSynthetic = {
                accuracy: accuracy,
                precision: precision,
                recall: recall,
                f1Score: f1Score
            };

            document.getElementById('syntheticResults').innerHTML += `
                    <div class="info-box">
                        <strong>üéØ Treinamento com Dados Sint√©ticos Conclu√≠do!</strong><br>
                        Total de dados: ${combinedData.length} (${processedData.length} originais + ${syntheticData.length} sint√©ticos)<br>
                        Dados de treino: ${trainData.length}<br>
                        Dados de teste: ${testData.length}
                    </div>
                `;

            // Comparar com modelo original
            const originalAcc = results.knn ? results.knn.accuracy : 0;
            const improvement = accuracy - originalAcc;

            document.getElementById('syntheticMetrics').innerHTML = `
                    <div class="metric-card">
                        <div class="metric-value">${(accuracy * 100).toFixed(1)}%</div>
                        <div class="metric-label">Acur√°cia (com sint√©ticos)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${(originalAcc * 100).toFixed(1)}%</div>
                        <div class="metric-label">Acur√°cia (original)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${improvement >= 0 ? '+' : ''}${(improvement * 100).toFixed(1)}%</div>
                        <div class="metric-label">Melhoria</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${(f1Score * 100).toFixed(1)}%</div>
                        <div class="metric-label">F1-Score</div>
                    </div>
                `;
        }, 1500);
    }

    // Implementa√ß√£o da Regress√£o Linear
    function trainLinearRegression() {
        document.getElementById('regressionResults').innerHTML = '<div class="loading"></div> Treinando modelo de Regress√£o Linear...';

        setTimeout(() => {
            // Usar todas as features exceto area para prever area
            const X = rawData.map(row => [
                1, // bias term
                row.mean_radius,
                row.mean_texture,
                row.mean_perimeter,
                row.mean_smoothness
            ]);
            const y = rawData.map(row => row.mean_area);

            // Dividir em treino e teste
            const indices = Array.from({length: X.length}, (_, i) => i);
            indices.sort(() => Math.random() - 0.5);

            const trainSize = Math.floor(X.length * 0.8);
            const trainIndices = indices.slice(0, trainSize);
            const testIndices = indices.slice(trainSize);

            const X_train = trainIndices.map(i => X[i]);
            const y_train = trainIndices.map(i => y[i]);
            const X_test = testIndices.map(i => X[i]);
            const y_test = testIndices.map(i => y[i]);

            // Calcular coeficientes usando m√©todo dos m√≠nimos quadrados
            // Œ≤ = (X^T * X)^(-1) * X^T * y
            const XT = transpose(X_train);
            const XTX = matrixMultiply(XT, X_train);
            const XTX_inv = matrixInverse(XTX);
            const XTy = matrixVectorMultiply(XT, y_train);
            const coefficients = matrixVectorMultiply(XTX_inv, XTy);

            // Fazer predi√ß√µes
            const y_pred_train = X_train.map(row =>
                row.reduce((sum, val, idx) => sum + val * coefficients[idx], 0)
            );
            const y_pred_test = X_test.map(row =>
                row.reduce((sum, val, idx) => sum + val * coefficients[idx], 0)
            );

            // Calcular m√©tricas
            const mse_train = meanSquaredError(y_train, y_pred_train);
            const mse_test = meanSquaredError(y_test, y_pred_test);
            const r2_train = rSquared(y_train, y_pred_train);
            const r2_test = rSquared(y_test, y_pred_test);
            const mae_test = meanAbsoluteError(y_test, y_pred_test);

            // Armazenar modelo
            regressionModel = {
                coefficients: coefficients,
                mse_train: mse_train,
                mse_test: mse_test,
                r2_train: r2_train,
                r2_test: r2_test,
                mae_test: mae_test,
                y_test: y_test,
                y_pred_test: y_pred_test,
                residuals: y_test.map((actual, i) => actual - y_pred_test[i])
            };

            results.regression = regressionModel;

            document.getElementById('regressionResults').innerHTML = `
                    <div class="info-box">
                        <strong>üìà Modelo de Regress√£o Linear Treinado!</strong><br>
                        Vari√°vel dependente: √Årea m√©dia do tumor<br>
                        Vari√°veis independentes: Raio, Textura, Per√≠metro, Suavidade<br>
                        Dados de treino: ${X_train.length} amostras<br>
                        Dados de teste: ${X_test.length} amostras<br><br>

                        <strong>Equa√ß√£o do modelo:</strong><br>
                        √Årea = ${coefficients[0].toFixed(3)} +
                        ${coefficients[1].toFixed(3)} √ó Raio +
                        ${coefficients[2].toFixed(3)} √ó Textura +
                        ${coefficients[3].toFixed(3)} √ó Per√≠metro +
                        ${coefficients[4].toFixed(3)} √ó Suavidade
                    </div>
                `;

            // Mostrar m√©tricas
            document.getElementById('regressionMetrics').innerHTML = `
                    <div class="metric-card">
                        <div class="metric-value">${r2_test.toFixed(3)}</div>
                        <div class="metric-label">R¬≤ (Teste)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${Math.sqrt(mse_test).toFixed(2)}</div>
                        <div class="metric-label">RMSE</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${mae_test.toFixed(2)}</div>
                        <div class="metric-label">MAE</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${mse_test.toFixed(2)}</div>
                        <div class="metric-label">MSE</div>
                    </div>
                `;

            // Plotar predi√ß√µes vs valores reais
            plotRegressionResults();

            document.getElementById('residualsBtn').disabled = false;
        }, 2000);
    }

    function plotRegressionResults() {
        const trace1 = {
            x: regressionModel.y_test,
            y: regressionModel.y_pred_test,
            mode: 'markers',
            type: 'scatter',
            name: 'Predi√ß√µes',
            marker: { color: '#3498db', size: 6 }
        };

        // Linha de refer√™ncia (predi√ß√£o perfeita)
        const minVal = Math.min(...regressionModel.y_test);
        const maxVal = Math.max(...regressionModel.y_test);
        const trace2 = {
            x: [minVal, maxVal],
            y: [minVal, maxVal],
            mode: 'lines',
            type: 'scatter',
            name: 'Predi√ß√£o Perfeita',
            line: { color: '#e74c3c', dash: 'dash' }
        };

        const layout = {
            title: 'Predi√ß√µes vs Valores Reais - Regress√£o Linear',
            xaxis: { title: '√Årea Real' },
            yaxis: { title: '√Årea Predita' },
            showlegend: true,
            plot_bgcolor: 'rgba(0,0,0,0)',
            paper_bgcolor: 'rgba(0,0,0,0)'
        };

        Plotly.newPlot('regressionPlots', [trace1, trace2], layout);
    }

    function analyzeResiduals() {
        document.getElementById('residualsPlot').innerHTML = '<div class="loading"></div> Analisando res√≠duos...';

        setTimeout(() => {
            // Plot 1: Res√≠duos vs Valores Preditos
            const trace1 = {
                x: regressionModel.y_pred_test,
                y: regressionModel.residuals,
                mode: 'markers',
                type: 'scatter',
                name: 'Res√≠duos',
                marker: { color: '#9b59b6', size: 6 }
            };

            // Linha horizontal em y=0
            const trace2 = {
                x: [Math.min(...regressionModel.y_pred_test), Math.max(...regressionModel.y_pred_test)],
                y: [0, 0],
                mode: 'lines',
                type: 'scatter',
                name: 'Zero',
                line: { color: '#e74c3c', dash: 'dash' }
            };

            const layout1 = {
                title: 'An√°lise de Res√≠duos - Res√≠duos vs Predi√ß√µes',
                xaxis: { title: 'Valores Preditos' },
                yaxis: { title: 'Res√≠duos' },
                showlegend: false,
                plot_bgcolor: 'rgba(0,0,0,0)',
                paper_bgcolor: 'rgba(0,0,0,0)'
            };

            // Plot 2: Histograma dos res√≠duos
            const trace3 = {
                x: regressionModel.residuals,
                type: 'histogram',
                nbinsx: 20,
                marker: { color: '#2ecc71', opacity: 0.7 },
                name: 'Distribui√ß√£o dos Res√≠duos'
            };

            const layout2 = {
                title: 'Distribui√ß√£o dos Res√≠duos',
                xaxis: { title: 'Res√≠duos' },
                yaxis: { title: 'Frequ√™ncia' },
                showlegend: false,
                plot_bgcolor: 'rgba(0,0,0,0)',
                paper_bgcolor: 'rgba(0,0,0,0)'
            };

            // Criar subplot
            const fig = Plotly.subPlot([
                { data: [trace1, trace2], layout: layout1 },
                { data: [trace3], layout: layout2 }
            ]);

            Plotly.newPlot('residualsPlot', [trace1, trace2], layout1);

            // Adicionar segundo gr√°fico
            setTimeout(() => {
                const residualsDiv = document.createElement('div');
                residualsDiv.id = 'residualsHistogram';
                residualsDiv.className = 'plot-container';
                document.getElementById('residualsPlot').appendChild(residualsDiv);
                Plotly.newPlot('residualsHistogram', [trace3], layout2);
            }, 500);

            // An√°lise estat√≠stica dos res√≠duos
            const residualStats = analyzeResidualsStats(regressionModel.residuals);

            document.getElementById('residualsPlot').innerHTML += `
                    <div class="info-box">
                        <strong>üìä An√°lise Estat√≠stica dos Res√≠duos:</strong><br>
                        M√©dia dos res√≠duos: ${residualStats.mean.toFixed(4)}<br>
                        Desvio padr√£o: ${residualStats.std.toFixed(4)}<br>
                        Normalidade (Jarque-Bera): ${residualStats.isNormal ? 'Aceita' : 'Rejeitada'}<br>
                        Homocedasticidade: ${residualStats.isHomoscedastic ? 'Sim' : 'N√£o'}<br><br>

                        <strong>üí° Interpreta√ß√£o:</strong><br>
                        ${residualStats.interpretation}
                    </div>
                `;

            // Gerar an√°lise final
            generateFinalAnalysis();
        }, 1500);
    }

    function analyzeResidualsStats(residuals) {
        const mean = residuals.reduce((a, b) => a + b) / residuals.length;
        const variance = residuals.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / residuals.length;
        const std = Math.sqrt(variance);

        // Teste simples de normalidade (baseado em skewness e kurtosis)
        const skewness = calculateSkewness(residuals, mean, std);
        const kurtosis = calculateKurtosis(residuals, mean, std);
        const isNormal = Math.abs(skewness) < 2 && Math.abs(kurtosis - 3) < 2;

        // Teste simples de homocedasticidade (varia√ß√£o dos res√≠duos)
        const firstHalf = residuals.slice(0, Math.floor(residuals.length / 2));
        const secondHalf = residuals.slice(Math.floor(residuals.length / 2));
        const var1 = calculateVariance(firstHalf);
        const var2 = calculateVariance(secondHalf);
        const isHomoscedastic = Math.abs(var1 - var2) / Math.max(var1, var2) < 0.5;

        let interpretation = '';
        if (Math.abs(mean) < 0.1) {
            interpretation += '‚úÖ Res√≠duos centrados em zero (boa especifica√ß√£o do modelo). ';
        } else {
            interpretation += '‚ö†Ô∏è Res√≠duos n√£o centrados (poss√≠vel vi√©s no modelo). ';
        }

        if (isNormal) {
            interpretation += '‚úÖ Res√≠duos seguem distribui√ß√£o normal. ';
        } else {
            interpretation += '‚ö†Ô∏è Res√≠duos n√£o seguem distribui√ß√£o normal. ';
        }

        if (isHomoscedastic) {
            interpretation += '‚úÖ Vari√¢ncia constante (homocedasticidade).';
        } else {
            interpretation += '‚ö†Ô∏è Vari√¢ncia n√£o constante (heterocedasticidade).';
        }

        return {
            mean,
            std,
            skewness,
            kurtosis,
            isNormal,
            isHomoscedastic,
            interpretation
        };
    }

    function generateFinalAnalysis() {
        const analysisHTML = `
                <div class="info-box">
                    <h3>üéØ An√°lise Comparativa Final</h3>

                    <h4>üìä Classifica√ß√£o vs Regress√£o:</h4>
                    <strong>Classifica√ß√£o (KNN):</strong><br>
                    ‚Ä¢ Objetivo: Prever se tumor √© maligno ou benigno (vari√°vel categ√≥rica)<br>
                    ‚Ä¢ M√©trica principal: Acur√°cia = ${results.knn ? (results.knn.accuracy * 100).toFixed(1) : 'N/A'}%<br>
                    ‚Ä¢ Outras m√©tricas: Precis√£o, Recall, F1-Score<br>
                    ‚Ä¢ Algoritmo: K-Nearest Neighbors (aprendizado baseado em inst√¢ncias)<br><br>

                    <strong>Regress√£o Linear:</strong><br>
                    ‚Ä¢ Objetivo: Prever √°rea m√©dia do tumor (vari√°vel cont√≠nua)<br>
                    ‚Ä¢ M√©trica principal: R¬≤ = ${results.regression ? results.regression.r2_test.toFixed(3) : 'N/A'}<br>
                    ‚Ä¢ Outras m√©tricas: MSE, RMSE, MAE<br>
                    ‚Ä¢ Algoritmo: Regress√£o Linear (m√©todo dos m√≠nimos quadrados)<br><br>

                    <h4>üîç Principais Diferen√ßas:</h4>
                    ‚Ä¢ <strong>Tipo de vari√°vel:</strong> Classifica√ß√£o prediz categorias, Regress√£o prediz valores cont√≠nuos<br>
                    ‚Ä¢ <strong>M√©tricas:</strong> Classifica√ß√£o usa acur√°cia/precis√£o, Regress√£o usa R¬≤/MSE<br>
                    ‚Ä¢ <strong>Interpreta√ß√£o:</strong> Classifica√ß√£o: "√â maligno?", Regress√£o: "Qual o tamanho?"<br>
                    ‚Ä¢ <strong>Aplica√ß√£o:</strong> Classifica√ß√£o para diagn√≥stico, Regress√£o para quantifica√ß√£o<br><br>

                    <h4>üí° Insights dos Resultados:</h4>
                    ${generateInsights()}
                </div>

                <div class="warning-box">
                    <h4>‚ö†Ô∏è Limita√ß√µes e Considera√ß√µes:</h4>
                    ‚Ä¢ Dataset sint√©tico para fins educacionais<br>
                    ‚Ä¢ Valida√ß√£o cruzada n√£o implementada (divis√£o simples treino/teste)<br>
                    ‚Ä¢ N√£o foram testados outros algoritmos de classifica√ß√£o/regress√£o<br>
                    ‚Ä¢ An√°lise de features e sele√ß√£o de vari√°veis n√£o realizada<br>
                    ‚Ä¢ Em aplica√ß√µes reais, seria necess√°rio valida√ß√£o m√©dica especializada
                </div>
            `;

        document.getElementById('finalAnalysis').innerHTML = analysisHTML;

        // Plotar compara√ß√£o de performance
        plotPerformanceComparison();
    }

    function generateInsights() {
        let insights = '';

        if (results.knn && results.knn.accuracy > 0.9) {
            insights += '‚úÖ Modelo KNN apresentou excelente performance (>90% acur√°cia)<br>';
        } else if (results.knn && results.knn.accuracy > 0.8) {
            insights += '‚úÖ Modelo KNN apresentou boa performance (>80% acur√°cia)<br>';
        } else {
            insights += '‚ö†Ô∏è Modelo KNN pode precisar de otimiza√ß√£o<br>';
        }

        if (results.regression && results.regression.r2_test > 0.8) {
            insights += '‚úÖ Modelo de regress√£o explica bem a variabilidade da √°rea (R¬≤ > 0.8)<br>';
        } else if (results.regression && results.regression.r2_test > 0.6) {
            insights += '‚úÖ Modelo de regress√£o tem poder explicativo moderado<br>';
        } else {
            insights += '‚ö†Ô∏è Modelo de regress√£o pode precisar de mais features<br>';
        }

        if (results.knnSynthetic && results.knn) {
            const improvement = results.knnSynthetic.accuracy - results.knn.accuracy;
            if (improvement > 0.05) {
                insights += '‚úÖ Dados sint√©ticos melhoraram significativamente a performance<br>';
            } else if (improvement > 0) {
                insights += '‚úÖ Dados sint√©ticos trouxeram melhoria modesta<br>';
            } else {
                insights += '‚ö†Ô∏è Dados sint√©ticos n√£o melhoraram a performance<br>';
            }
        }

        return insights;
    }

    function plotPerformanceComparison() {
        if (!results.knn || !results.regression) return;

        const trace1 = {
            x: ['Classifica√ß√£o (KNN)', 'Regress√£o Linear'],
            y: [results.knn.accuracy * 100, results.regression.r2_test * 100],
            type: 'bar',
            marker: {
                color: ['#3498db', '#e74c3c'],
                opacity: 0.8
            },
            text: [`${(results.knn.accuracy * 100).toFixed(1)}%`, `${(results.regression.r2_test * 100).toFixed(1)}%`],
            textposition: 'auto'
        };

        const layout = {
            title: 'Compara√ß√£o de Performance dos Modelos',
            yaxis: {
                title: 'Performance (%)',
                range: [0, 100]
            },
            showlegend: false,
            plot_bgcolor: 'rgba(0,0,0,0)',
            paper_bgcolor: 'rgba(0,0,0,0)'
        };

        Plotly.newPlot('performanceComparison', [trace1], layout);
    }

    // Fun√ß√µes auxiliares matem√°ticas
    function transpose(matrix) {
        return matrix[0].map((_, colIndex) => matrix.map(row => row[colIndex]));
    }

    function matrixMultiply(a, b) {
        const result = [];
        for (let i = 0; i < a.length; i++) {
            result[i] = [];
            for (let j = 0; j < b[0].length; j++) {
                let sum = 0;
                for (let k = 0; k < b.length; k++) {
                    sum += a[i][k] * b[k][j];
                }
                result[i][j] = sum;
            }
        }
        return result;
    }

    function matrixVectorMultiply(matrix, vector) {
        return matrix.map(row =>
            row.reduce((sum, val, idx) => sum + val * vector[idx], 0)
        );
    }

    function matrixInverse(matrix) {
        const n = matrix.length;
        const identity = Array(n).fill().map(() => Array(n).fill(0));
        for (let i = 0; i < n; i++) identity[i][i] = 1;

        const augmented = matrix.map((row, i) => [...row, ...identity[i]]);

        // Elimina√ß√£o gaussiana
        for (let i = 0; i < n; i++) {
            let maxRow = i;
            for (let k = i + 1; k < n; k++) {
                if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {
                    maxRow = k;
                }
            }
            [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];

            for (let k = i + 1; k < n; k++) {
                const factor = augmented[k][i] / augmented[i][i];
                for (let j = i; j < 2 * n; j++) {
                    augmented[k][j] -= factor * augmented[i][j];
                }
            }
        }

        // Substitui√ß√£o para tr√°s
        for (let i = n - 1; i >= 0; i--) {
            for (let k = i - 1; k >= 0; k--) {
                const factor = augmented[k][i] / augmented[i][i];
                for (let j = i; j < 2 * n; j++) {
                    augmented[k][j] -= factor * augmented[i][j];
                }
            }
        }

        // Normalizar
        for (let i = 0; i < n; i++) {
            const divisor = augmented[i][i];
            for (let j = 0; j < 2 * n; j++) {
                augmented[i][j] /= divisor;
            }
        }

        return augmented.map(row => row.slice(n));
    }

    function meanSquaredError(actual, predicted) {
        return actual.reduce((sum, val, idx) =>
            sum + Math.pow(val - predicted[idx], 2), 0
        ) / actual.length;
    }

    function meanAbsoluteError(actual, predicted) {
        return actual.reduce((sum, val, idx) =>
            sum + Math.abs(val - predicted[idx]), 0
        ) / actual.length;
    }

    function rSquared(actual, predicted) {
        const actualMean = actual.reduce((a, b) => a + b) / actual.length;
        const totalSumSquares = actual.reduce((sum, val) =>
            sum + Math.pow(val - actualMean, 2), 0
        );
        const residualSumSquares = actual.reduce((sum, val, idx) =>
            sum + Math.pow(val - predicted[idx], 2), 0
        );
        return 1 - (residualSumSquares / totalSumSquares);
    }

    function calculateSkewness(data, mean, std) {
        const n = data.length;
        const sum = data.reduce((acc, val) => acc + Math.pow((val - mean) / std, 3), 0);
        return (n / ((n - 1) * (n - 2))) * sum;
    }

    function calculateKurtosis(data, mean, std) {
        const n = data.length;
        const sum = data.reduce((acc, val) => acc + Math.pow((val - mean) / std, 4), 0);
        return (n * (n + 1) / ((n - 1) * (n - 2) * (n - 3))) * sum -
            (3 * Math.pow(n - 1, 2) / ((n - 2) * (n - 3)));
    }

    function calculateVariance(data) {
        const mean = data.reduce((a, b) => a + b) / data.length;
        return data.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / data.length;
    }
</script>
</body>
</html>